// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EthSendTransactionIntent eth send transaction intent
//
// swagger:model EthSendTransactionIntent
type EthSendTransactionIntent struct {

	// CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet).
	// Required: true
	// Enum: [eip155:1 eip155:11155111 eip155:8453 eip155:84532]
	Caip2 *string `json:"caip2"`

	// Hex-encoded call data for contract interactions.
	Data *string `json:"data,omitempty"`

	// Unix timestamp after which the Gas Station meta-transaction is no longer valid. Only used when sponsor=true.
	Deadline *string `json:"deadline,omitempty"`

	// A wallet or private key address to sign with. This does not support private key IDs.
	// Required: true
	From *string `json:"from"`

	// Maximum amount of gas to use for this transaction.
	// Required: true
	GasLimit *string `json:"gasLimit"`

	// Maximum total fee per gas unit (base fee + priority fee) in wei, for EIP-1559 transactions.
	// Required: true
	MaxFeePerGas *string `json:"maxFeePerGas"`

	// Maximum priority fee (tip) per gas unit in wei, for EIP-1559 transactions.
	// Required: true
	MaxPriorityFeePerGas *string `json:"maxPriorityFeePerGas"`

	// Transaction nonce.
	// Required: true
	Nonce *string `json:"nonce"`

	// Whether to sponsor this transaction via Gas Station.
	Sponsor *bool `json:"sponsor,omitempty"`

	// Recipient address as a hex string with 0x prefix.
	// Required: true
	To *string `json:"to"`

	// Amount of native asset to send in wei.
	Value *string `json:"value,omitempty"`
}

// Validate validates this eth send transaction intent
func (m *EthSendTransactionIntent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCaip2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGasLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxFeePerGas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxPriorityFeePerGas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNonce(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var ethSendTransactionIntentTypeCaip2PropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eip155:1","eip155:11155111","eip155:8453","eip155:84532"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ethSendTransactionIntentTypeCaip2PropEnum = append(ethSendTransactionIntentTypeCaip2PropEnum, v)
	}
}

const (

	// EthSendTransactionIntentCaip2Eip1551 captures enum value "eip155:1"
	EthSendTransactionIntentCaip2Eip1551 string = "eip155:1"

	// EthSendTransactionIntentCaip2Eip15511155111 captures enum value "eip155:11155111"
	EthSendTransactionIntentCaip2Eip15511155111 string = "eip155:11155111"

	// EthSendTransactionIntentCaip2Eip1558453 captures enum value "eip155:8453"
	EthSendTransactionIntentCaip2Eip1558453 string = "eip155:8453"

	// EthSendTransactionIntentCaip2Eip15584532 captures enum value "eip155:84532"
	EthSendTransactionIntentCaip2Eip15584532 string = "eip155:84532"
)

// prop value enum
func (m *EthSendTransactionIntent) validateCaip2Enum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ethSendTransactionIntentTypeCaip2PropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EthSendTransactionIntent) validateCaip2(formats strfmt.Registry) error {

	if err := validate.Required("caip2", "body", m.Caip2); err != nil {
		return err
	}

	// value enum
	if err := m.validateCaip2Enum("caip2", "body", *m.Caip2); err != nil {
		return err
	}

	return nil
}

func (m *EthSendTransactionIntent) validateFrom(formats strfmt.Registry) error {

	if err := validate.Required("from", "body", m.From); err != nil {
		return err
	}

	return nil
}

func (m *EthSendTransactionIntent) validateGasLimit(formats strfmt.Registry) error {

	if err := validate.Required("gasLimit", "body", m.GasLimit); err != nil {
		return err
	}

	return nil
}

func (m *EthSendTransactionIntent) validateMaxFeePerGas(formats strfmt.Registry) error {

	if err := validate.Required("maxFeePerGas", "body", m.MaxFeePerGas); err != nil {
		return err
	}

	return nil
}

func (m *EthSendTransactionIntent) validateMaxPriorityFeePerGas(formats strfmt.Registry) error {

	if err := validate.Required("maxPriorityFeePerGas", "body", m.MaxPriorityFeePerGas); err != nil {
		return err
	}

	return nil
}

func (m *EthSendTransactionIntent) validateNonce(formats strfmt.Registry) error {

	if err := validate.Required("nonce", "body", m.Nonce); err != nil {
		return err
	}

	return nil
}

func (m *EthSendTransactionIntent) validateTo(formats strfmt.Registry) error {

	if err := validate.Required("to", "body", m.To); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this eth send transaction intent based on context it is used
func (m *EthSendTransactionIntent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EthSendTransactionIntent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EthSendTransactionIntent) UnmarshalBinary(b []byte) error {
	var res EthSendTransactionIntent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
