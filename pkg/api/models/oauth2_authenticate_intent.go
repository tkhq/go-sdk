// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Oauth2AuthenticateIntent oauth2 authenticate intent
//
// swagger:model Oauth2AuthenticateIntent
type Oauth2AuthenticateIntent struct {

	// The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow
	// Required: true
	AuthCode *string `json:"authCode"`

	// An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token
	BearerTokenTargetPublicKey *string `json:"bearerTokenTargetPublicKey,omitempty"`

	// The code verifier used by OAuth 2.0 PKCE providers
	// Required: true
	CodeVerifier *string `json:"codeVerifier"`

	// An optional nonce used by the client to prevent replay/substitution of an ID token
	Nonce *string `json:"nonce,omitempty"`

	// The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow
	// Required: true
	Oauth2CredentialID *string `json:"oauth2CredentialId"`

	// The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider
	// Required: true
	RedirectURI *string `json:"redirectUri"`
}

// Validate validates this oauth2 authenticate intent
func (m *Oauth2AuthenticateIntent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCodeVerifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOauth2CredentialID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedirectURI(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Oauth2AuthenticateIntent) validateAuthCode(formats strfmt.Registry) error {

	if err := validate.Required("authCode", "body", m.AuthCode); err != nil {
		return err
	}

	return nil
}

func (m *Oauth2AuthenticateIntent) validateCodeVerifier(formats strfmt.Registry) error {

	if err := validate.Required("codeVerifier", "body", m.CodeVerifier); err != nil {
		return err
	}

	return nil
}

func (m *Oauth2AuthenticateIntent) validateOauth2CredentialID(formats strfmt.Registry) error {

	if err := validate.Required("oauth2CredentialId", "body", m.Oauth2CredentialID); err != nil {
		return err
	}

	return nil
}

func (m *Oauth2AuthenticateIntent) validateRedirectURI(formats strfmt.Registry) error {

	if err := validate.Required("redirectUri", "body", m.RedirectURI); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this oauth2 authenticate intent based on context it is used
func (m *Oauth2AuthenticateIntent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Oauth2AuthenticateIntent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Oauth2AuthenticateIntent) UnmarshalBinary(b []byte) error {
	var res Oauth2AuthenticateIntent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
