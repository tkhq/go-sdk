// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SolSendTransactionIntent sol send transaction intent
//
// swagger:model SolSendTransactionIntent
type SolSendTransactionIntent struct {

	// CAIP-2 chain ID (e.g., 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp' for Solana mainnet).
	// Required: true
	// Enum: [solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY]
	Caip2 *string `json:"caip2"`

	// user-provided blockhash for replay protection / deadline control. If omitted and sponsor=true, we fetch a fresh blockhash during execution
	RecentBlockhash *string `json:"recentBlockhash,omitempty"`

	// A wallet or private key address to sign with. This does not support private key IDs.
	// Required: true
	SignWith *string `json:"signWith"`

	// Whether to sponsor this transaction via Gas Station.
	Sponsor *bool `json:"sponsor,omitempty"`

	// Base64-encoded serialized unsigned Solana transaction
	// Required: true
	UnsignedTransaction *string `json:"unsignedTransaction"`
}

// Validate validates this sol send transaction intent
func (m *SolSendTransactionIntent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCaip2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignWith(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnsignedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var solSendTransactionIntentTypeCaip2PropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp","solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG","solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		solSendTransactionIntentTypeCaip2PropEnum = append(solSendTransactionIntentTypeCaip2PropEnum, v)
	}
}

const (

	// SolSendTransactionIntentCaip2Solana5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp captures enum value "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
	SolSendTransactionIntentCaip2Solana5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp string = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"

	// SolSendTransactionIntentCaip2SolanaEtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG captures enum value "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG"
	SolSendTransactionIntentCaip2SolanaEtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG string = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG"

	// SolSendTransactionIntentCaip2Solana4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY captures enum value "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY"
	SolSendTransactionIntentCaip2Solana4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY string = "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY"
)

// prop value enum
func (m *SolSendTransactionIntent) validateCaip2Enum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, solSendTransactionIntentTypeCaip2PropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SolSendTransactionIntent) validateCaip2(formats strfmt.Registry) error {

	if err := validate.Required("caip2", "body", m.Caip2); err != nil {
		return err
	}

	// value enum
	if err := m.validateCaip2Enum("caip2", "body", *m.Caip2); err != nil {
		return err
	}

	return nil
}

func (m *SolSendTransactionIntent) validateSignWith(formats strfmt.Registry) error {

	if err := validate.Required("signWith", "body", m.SignWith); err != nil {
		return err
	}

	return nil
}

func (m *SolSendTransactionIntent) validateUnsignedTransaction(formats strfmt.Registry) error {

	if err := validate.Required("unsignedTransaction", "body", m.UnsignedTransaction); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this sol send transaction intent based on context it is used
func (m *SolSendTransactionIntent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SolSendTransactionIntent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SolSendTransactionIntent) UnmarshalBinary(b []byte) error {
	var res SolSendTransactionIntent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
