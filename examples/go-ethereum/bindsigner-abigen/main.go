package main

import (
	"context"
	"encoding/hex"
	"fmt"
	"log"
	"math/big"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/joho/godotenv"

	"github.com/tkhq/go-sdk"
	"github.com/tkhq/go-sdk/pkg/api/client/signing"
	"github.com/tkhq/go-sdk/pkg/api/models"
	"github.com/tkhq/go-sdk/pkg/apikey"

	"github.com/tkhq/go-sdk/examples/go-ethereum/bindsigner-abigen/erc20"
)

func main() {

	// Load env variables
	err := godotenv.Load()
	if err != nil {
		log.Fatalf("Error loading .env file: %v", err)
	}

	rpcURL := os.Getenv("RPC_URL")
	signWith := os.Getenv("SIGN_WITH")

	fromAddress := common.HexToAddress(signWith)

	if rpcURL == "" || signWith == "" {
		log.Fatal("RPC_URL and SIGN_WITH must be set")
	}

	// Organization API key used to stamp the requests to Turnkey
	apiKey, err := apikey.FromTurnkeyPrivateKey(os.Getenv("TURNKEY_API_PRIVATE_KEY"), apikey.SchemeP256)

	if err != nil {
		log.Fatal("creating API key: %w", err)
	}

	client, err := sdk.New(sdk.WithAPIKey(apiKey))
	if err != nil {
		log.Fatal("creating SDK client: %w", err)
	}

	// Ethereum RPC client + chainID
	rpc, err := ethclient.Dial(rpcURL)
	if err != nil {
		log.Fatal("rpc connection error:", err)
	}

	chainID, err := rpc.NetworkID(context.Background())
	if err != nil {
		log.Fatal("failed to get chain ID:", err)
	}

	// Turnkey-backed bind.TransactOpts
	signerFn := MakeTurnkeySignerFn(client, signWith, chainID)

	// This is exactly what abigen-generated bindings expect
	auth := &bind.TransactOpts{
		From:   fromAddress,
		Signer: signerFn,
		// You can optionally set:
		//   auth.GasLimit, auth.GasFeeCap, auth.GasTipCap, auth.Nonce
		// If you leave them zero/nil, bind will estimate/fill them.
	}

	// Bind an ERC20 contract generated by abigen
	// Deployed ERC20 contract address on the same network
	tokenAddr := common.HexToAddress(os.Getenv("CONTRACT_ADDRESS"))

	token, err := erc20.NewErc20(tokenAddr, rpc)
	if err != nil {
		log.Fatal("failed to bind ERC20:", err)
	}

	// Call transfer(to, amount) via abigen to self
	to := fromAddress
	amount := big.NewInt(1_000_000_000_000_000_000) // 1 token with 18 decimals

	fmt.Println("â†’ Calling ERC20.transfer via abigen + Turnkey...")

	// This will build a tx internally
	// Call your SignerFn (which calls Turnkey)
	// Broadcast the tx using the rpc client
	tx, err := token.Transfer(auth, to, amount)
	if err != nil {
		log.Fatalf("erc20 transfer error: %v", err)
	}

	fmt.Println("Broadcast OK, tx hash:", tx.Hash().Hex())
}

// Turnkey-backed bind.SignerFn
// cloneTxWithChainID rebuilds a DynamicFeeTx with the given chainID (needed when bind / upstream code left ChainId empty and expects the signer to enforce it)
func cloneTxWithChainID(tx *types.Transaction, chainID *big.Int) *types.Transaction {
	if tx.Type() != types.DynamicFeeTxType {
		return tx
	}

	to := tx.To()

	newTx := &types.DynamicFeeTx{
		ChainID:    chainID,
		Nonce:      tx.Nonce(),
		GasTipCap:  tx.GasTipCap(),
		GasFeeCap:  tx.GasFeeCap(),
		Gas:        tx.Gas(),
		To:         to,
		Value:      tx.Value(),
		Data:       tx.Data(),
		AccessList: tx.AccessList(),
	}

	return types.NewTx(newTx)
}

// MakeTurnkeySignerFn returns a bind.SignerFn that:
//   - normalizes the transaction (ensures chainID is set)
//   - builds the EIP-1559 unsigned payload Turnkey expects
//   - calls SignTransactionV2
//   - returns a fully signed *types.Transaction
func MakeTurnkeySignerFn(client *sdk.Client, signWith string, chainID *big.Int) bind.SignerFn {
	return func(from common.Address, tx *types.Transaction) (*types.Transaction, error) {
		// Ensure signer address matches the Turnkey address
		if !strings.EqualFold(from.Hex(), signWith) {
			return nil, fmt.Errorf("signer mismatch: from=%s, signWith=%s", from.Hex(), signWith)
		}

		// This example only supports EIP-1559 (DynamicFee) txs.
		if tx.Type() != types.DynamicFeeTxType {
			return nil, fmt.Errorf("only DynamicFeeTxType (eip-1559) supported in this example")
		}

		// Some bind flows set ChainId only via the signer. If it's empty/zero,
		// rebuild the DynamicFeeTx with the real chainID.
		if tx.ChainId() == nil || tx.ChainId().Cmp(big.NewInt(0)) == 0 {
			tx = cloneTxWithChainID(tx, chainID)
		}

		// Build the unsigned EIP-1559 payload:
		// [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList]
		unsignedPayload := []any{
			tx.ChainId(),
			tx.Nonce(),
			tx.GasTipCap(),
			tx.GasFeeCap(),
			tx.Gas(),
			tx.To(),
			tx.Value(),
			tx.Data(),
			tx.AccessList(),
		}

		rlpBytes, err := rlp.EncodeToBytes(unsignedPayload)
		if err != nil {
			return nil, fmt.Errorf("failed to rlp-encode unsigned tx: %w", err)
		}

		// Prepend EIP-1559 type byte 0x02
		unsigned := append([]byte{types.DynamicFeeTxType}, rlpBytes...)
		unsignedHex := hex.EncodeToString(unsigned) // Turnkey expects hex without 0x

		// Prepare Turnkey SignTransactionV2 request
		ts := strconv.FormatInt(time.Now().UnixMilli(), 10)

		// Get the Turnkey organization id from .env
		organizationId := os.Getenv("TURNKEY_ORGANIZATION_ID")

		params := signing.NewSignTransactionParams().WithBody(&models.SignTransactionRequest{
			OrganizationID: &organizationId,
			TimestampMs:    &ts,
			Parameters: &models.SignTransactionIntentV2{
				SignWith:            &signWith,
				Type:                models.TransactionTypeEthereum.Pointer(),
				UnsignedTransaction: &unsignedHex,
			},
			Type: (*string)(models.ActivityTypeSignTransactionV2.Pointer()),
		})

		resp, err := client.V0().Signing.SignTransaction(params, client.Authenticator)
		if err != nil {
			return nil, fmt.Errorf("turnkey SignTransactionV2 error: %w", err)
		}

		signedHex := resp.Payload.Activity.
			Result.
			SignTransactionResult.
			SignedTransaction
		if signedHex == nil {
			return nil, fmt.Errorf("turnkey returned nil signed transaction")
		}

		rawSigned, err := hex.DecodeString(strings.TrimPrefix(*signedHex, "0x"))
		if err != nil {
			return nil, fmt.Errorf("failed to hex-decode signed tx: %w", err)
		}

		finalTx := new(types.Transaction)
		if err := finalTx.UnmarshalBinary(rawSigned); err != nil {
			return nil, fmt.Errorf("failed to unmarshal signed tx: %w", err)
		}

		return finalTx, nil
	}
}
